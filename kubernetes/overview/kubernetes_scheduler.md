# 浅谈调度器
由于kubernetes的最小调度单元是pod，并且kubernetes是一个容器集群编排与管理的项目，那么当有pod申请创建的时候，kubernetes是如何将pod调度到“合适”的node节点上的呢，这就是kube-scheduler组件的主要工作了。

我们先来看一下kube-scheduler调度的主要流程， 如下图所示：

![](https://github.com/hanlaipeng/project-analysis/blob/master/img/scheduler-all.png)

从调度的流程图中可以看出来它其实主要分为两个部分：监听、调度，而调度又分为两部分：调度成功和调度失败的抢占，下面我们来分别介绍一下：
## 监听
我们可以看到，调度的时候有一个调度的队列，这个队列是一个先进先出的优先级队列，为什么会有优先级这一说呢，这个到抢占的时候就会用到了，高优先级的pod调度失败的时候可以抢占低优先级的pod。这个所谓的监听的过程，其实就是起了一个watch的进程，他会时刻关注etcd中与调度相关的API对象的变化，比如：pod，node等，当一个pod的新建信息写入etcd的时候，scheduler的监听进程就会监听到资源的变化，将新建的pod加入等待调度的队列。

同时，为了提高调度的性能，scheduler还对调度所需要的一些信息进行了缓存，比如使用频率较高的node信息，这样就很直接的提高了调度过程中选择节点的效率。

## 调度
### 选择节点
从图中我们可以看到，整个调度的过程是串行的，scheduler从等待调度队列中获取到一个pod，然后进入调度流程，调度的时候首先先筛选出一个最合适的节点，然后将该节点与pod进行绑定，然后信息写回etcd中。其中筛选节点主要包含两个过程：

* Predicate（过滤）：该过程主要起到了过滤的作用，它会过滤掉不符合要求的node节点，比如，资源不满足需求的、节点有污点的等（这里的过滤条件我们后面再介绍），最终获取到一系列可以满足pod运行需求的node节点。
* Priority（打分）：当获取到一系列可以满足pod运行的node节点之后，调度器需要从中选择一个最合适节点将pod调度上去，那么它就会对这一系列的node节点进行打分，这个打分操作是并行，调度器定义了许多打分的策略，比如：选择空闲资源最多的节点、选择资源最平均的节点等打分策略，（策略我们后面再介绍）满足策略的分值会高一些，最后选择总分最高的节点，如果有相同分支的多个节点，那就随机选择一个。

>一般情况下，默认的default调度器并不能满足大多数用户的需求，用户就可以通过自定义Predicate和Priority策略，或者修改打分的权重，来调整调度的结果，以满足自己的需求。

当选择出来合适的节点之后，调度器并不会立刻将绑定的信息通过api-server写入etcd中，而是乐观的先更新调度器缓存中的信息，然后后面通过多线程的方式写入。

### 抢占
抢占，就是当集群的资源不能满足高优先级pod的时候，通过杀掉低优先级pod来调度高优先级pod的过程。当pod调度失败之后，调度器就会去评估失败的原因，是否满足抢占的需求，如果满足抢占的需求，那么就会将其加入到调度失败的队列中，发起抢占流程。整个抢占过程大概分为三步：

1. 调度器就会先复制一份当前node节点的信息，来模拟抢占的过程，通过删除节点上比该pod优先级低的pod，来查看改节点是否满足，记录下来满足的节点，并选择出来一个“代价”最小的节点，这个代价最小，就是被抢占的pod较少并且影响较小。
2. 记录调度pod的信息、被抢占pod的信息和节点信息，将调度的pod重新加回等待调度的队列中，为什么这里不直接选择抢占完成呢？是因为kill被抢占的pod的时候有一个优雅的退出时间（30s），在这个时间段很有可能会发生很多事情，比如新节点加入、pod结束等，都会改变调度的结果。
3. 开始抢占，调度器会起一个goroutine，去删除被抢占的pod，然后将这些pod重新加入等待调度的队列，等待重新调度。到此为止，抢占的基本流程就结束。

以上就是对kube-scheduler的基本介绍，后面会带来相应组件的源码分析。

