### [1.什么是Kubernetes-scheduler?](#什么是Kubernetes-scheduler?锚点)
### [2.云端资源调度器的调度模型](#云端资源调度器的调度模型锚点)
- #### [中央式调度模型](#中央式调度模型锚点)
- #### [两层式调度模型](#两层式调度模型锚点)
- #### [基于共享状态的调度模型](#基于共享状态的调度模型锚点)
### [3.资源调度策略](#资源调度策略锚点)
### [4.Kubernetes默认调度器存在的问题](#Kubernetes默认调度器存在的问题锚点)
---



<span id="什么是Kubernetes-scheduler?锚点"></span>
### 1.什么是Kubernetes-scheduler?
当集群中Master节点的API-Server将创建Pod的请求存储至Etcd后，有一个关键的步骤，即通过调度器程序(Kubernetes Scheduler)从当前集群中选择一个可用的最佳节点来接受并运行它，从而实现基于资源可用性将Pod资源公平的分配于集群节点之上。

我们在集群中通常是混合部署应用程序，这些应用可能是高CPU消耗的，高IO的，内存敏感的，或者GPU消耗的等等，由此导致调度问题复杂化，资源调度设计者需要考虑更多的限制条件和调度策略。

了解Kubernetes调度器，我们需要了解：

- 云端中调度模型的变化：

中央式调度模型---两层调度模型---基于共享状态的调度模型。

- 云端资源调度策略：

静态调度、动态调度、部分动态调度



<span id="云端资源调度器的调度模型锚点"></span>
### 2.云端资源调度器的调度模型
<span id="中央式调度模型锚点"></span>
- #### 中央式调度模型

中央式资源调度模型表现为所有集群状态信息都存储在唯一的调度器实例
上，可扩展性较差。随着集群规模的增长，快速膨胀的集群信息将会使单节点的资源调度器实例变得＂不堪重负＂，从而严重影响系统的整体性。

Docker公司的容器编排工具--Swarm就是中央式调度模型的典型实现。Swarm的调度器模块Scheduler支持的调度算法有Random,Spread和Binpack。

- Swarm的Scheduler    
    - Random算法不考虑其他别的因素，只是随机地选择集群中的一个节点检查其资源容量是否满足待调度容器的需求。如果满足，则将容器调度到该工作节点上；否则检查集群中的其他节点直到有一个满足要求或所有节点均不满足返回错误。
    - Spread算法是尽量将容器分散调度到不同的节点上，以实现集群范围内所有节点的负载均衡。该算法的执行过程就是先遍历集群中所有工作节点目前运行的容器个数，然后检查运行容器个数最少的那个工作节点是否满足资源需求，如果满足则选择该工作节点；否则检查运行容器第二、第三个...第N少的工作节点直到结束。
    - Binpack算法与Spread算法刚好相反，是尽量将容器集中调度到数量尽可能
    少的节点上，以实现集群节点的压缩。该算法的执行过程与Spread算法非常类似，只是Spread算法是优先检查运行容器个数最少的那个工作节点，而Binpack算法则刚好相反，优先检查运行容器个数最多的那个工作节点。Binpack算法的副作用是过多容器相互＂挤占＂同一个工作节点的系统资源导致运行的不可靠性。

<span id="两层式调度模型锚点"></span>
- #### 两层式资度模型

在两层式资源调度模型中，具体的作业调度算法是由每一个独立的调度框架实现的，资源调度器只负责资源的分发。两级调度模型将资源调度和任务分配分离，使任务的调度逻辑能够依据不同类型应用要求而进行定制，并且增加了集群内资源共享的可能性。

Apache基金会的Mesos为两层式资源调度器的典型代表。

Apache的Mesos使用DRF(Dominant Resources Fairness主导资源公平)算法实现资源的分配。DFS算法是一种考虑到不同用户对资源(包括：CPU和内存等)有不同需求而设计的一种公平分配算法。不同的task对不同类型的资源有需求，mesos会根据每一个task的需求占集群总资源的比率，为每一个task选取一个主导资源，并且计算这个主导资源在集群中所占用的比率，用这个比率给 task 进行优先级排序。每一次新的分配，都会优先选择把资源给当前所占比率最低的那个task。

<span id="基于共享状态的调度模型锚点"></span>
- #### 基于共享状态的调度模型

状态共享调度模型中的集群状态会被应用层次调度器独立更新，一旦本地有更新，
调度器会发布一个并发操作来更新所有共享集群状态。每个节点仅维护自己的状态，将更新发送给其它的代理如调度器、设备健康监控和资源控制系统。状态共享调度模型使用乐观锁进行共享状态的并发控制。

Google公司的Kubernetes为基于共享状态的资源调度模型的典型应用。

<span id="资源调度策略锚点"></span>
### 3.资源调度策略
- 静态调度：静态资源调度策略的前提是应用对资源的使用量基本保持不变，在资源申请的最初阶段就已完成资源的静态分配，并且在应用运行期间不再改变。
- 动态调度：动态调度策略则在应用运行期间周期性的统计资源使用情况，根据实际消耗的资源量，动态的调整应用的资源申请配额。动态调度的目的是按需将资源分配给应用，并且能充分利用系统资源，得到一个近似的资源配置最优解。
- 部分动态调度：态调度策略则综合了前两种策略，一部分资源配置的工作在系统的最初的阶段完成，另一部分资源配置工作在应用运行时根据资源负载情况动态的调整资源的分配，其目标是以消耗特定的计算资源为代价，来换取一个近似最优的资源配置方案。


<span id="Kubernetes的调度调度器锚点"></span>
### 3.Kubernetes的调度调度器

- 是共享状态的资源调度模型
- 采用静态资源调度策略

我们将Kubernetes集群调度器简单地看作是一个输入/输出的黑盒，那么输入就是待调度Pod和可用的工作节点列表，输出则是根据调度策略从可用的工作节点列表中选举出来的一个工作节点。

调度策略由三部分组成，分别是：预选、优选和选定。①预选过程中检查所有可用节点，筛选出符合 Pod要求的节点。这些节点成为下一流程的候选节点。②在预选流程筛选出来的节点中进一步进行筛选。使用优选策略分别计算出每一个可用节点的得分，得分最高的节点则为最适合被调度的节点。③如果优选调度策略计算出来的得分结果中，同时有两个或多个节点为最高分节点，那么就利用随机算法从这些节点中随机选择一个进行调度。

由于Kubernetes集群调度器提供了一个可插拔的算法框架，开发者能够很方便地往调度器添加各种自定义的调度算法。所以我们接下来主要研究预选和优选中==已经集成的策略==和可以改进的地方。

- 预选策略
    - PodFitsPorts：端口是否冲突。检查其值指定的端口是否已被节点上的其他容器或服务占用
    - PodFitsResources：资源是否够用
    - NoDiskConflit：挂载的磁盘是否冲突，检查Pod对象请求的存储卷在此节点是否可用

- 优选策略
    - LeastRequestedPriority：该策略从可用节点当中选择出目前资源消耗最少的节点，资源消耗越少的节点得分越高。
    - BalancedResourceAllocation：该策略从可用节点当中选择各项资源如 CPU、内存使用率最均衡的节点，资源越均衡的节点得分越高
    - SelectorSpreadPriority：首先查找与当前 Pod 对象匹配的 Service、ReplicationController、 ReplicaSet ( RS ）和 StatefulSet，而后查找与这些选择器匹配的现存 Pod 对象及其所在的节 点，则运行此类 Pod 对象越少的节点得分将越高。 简单来说，如其名称所示，此优选函数 会尽量将同一标签选择器匹配到的 Pod 资源分散到不同的节点上运行。 

<span id="Kubernetes默认调度器存在的问题锚点"></span>
### 4.Kubernetes默认调度器存在的问题
- 能否在提出新的预选、优选策略
- 无法在应用程序运行时按需对已分配的资源进行动态调整--申请多了资源浪费，少了不够。
- 无法重新对Pod进行调度，导致资源碎片等问题，等否对Pod重新部署，涉及到存储卷了。
- 资源监控方面，能否对资源使用进行预测，提前预警&&能否自动伸缩。






  
 



