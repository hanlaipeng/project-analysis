# 浅谈容器技术
说到容器，我们就不自觉的会想到docker，那么docker是什么呢？我们看docker的log是一条驮着很多集装箱的鲸鱼，我们可以很直观的从这个log上获取到一些信息，鲸鱼背上的集装箱（也就是容器）中装的可能是一个应用，可能是一个linux的环境，也可能是一个配置好的mysql服务等，而鲸鱼就可以驮着它到任何一个港口（也就是机器），将这个集装箱卸下， 开箱即用里面的服务。而docker就是做这么一件事的，它可以将一个服务或一个应用打包成一个容器，可以将容器搬到在不同的平台上，开箱即用该容器中的服务。而容器其实就可以理解成一个沙盒。

## 容器的隔离技术
我们现在机器上启动一个容器，在这里我启动的是busybox容器，启动指令如下：

```
$ docker run -ti busybox /bin/sh
```
我们通过-ti可以以交互的模式进入到打开的容器内部，打开容器时在容器中执行的指令为：/bin/sh，当你进入到容器的时候，在根目录下执行指令 ls，你就会发现这些目录，文件夹似曾相识，就好像在一个新的系统中是一样：

```
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
```
然后执行ps aux，你会发现1号进程就是我们在启动容器的时候设置的：/bin/sh指令

```
/ # ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    8 root      0:00 ps aux
```
然后我们在宿主机上执行 ps指令来查看/bin/sh，你会发现，宿主机给他分配的进程号是26750。

```
$ ps aux | grep /bin/sh
root     26750  0.0  0.0   1300   260 pts/0    Ss+  22:56   0:00 /bin/sh
```
这时候你也许就会产生一个疑问，容器是如何做到隔离的呢？

说到隔离，我们就不得不说Cgroups技术和Namespace技术，简单的来说，Namespace技术隔离了“环境”，而Cgroups限制了“资源”。

正如上面所看到的关于进程的隔离就是使用了PID Namespace，同时，Linux还提供了Mount Namespace，即实现了挂载点的隔离，容器中的进程只能看到隔离的挂载点的信息；Network Namepace，即实现了网络的隔离，每一个容器都有一套独立的网络系统，容器中的进程可以看到隔离的网络设备和信息，除此之外，提供了User Namespace，IPC Namespace等。在创建容器进程的时候，其实就指定了一组所需要的Namespace的参数，已实现对整个环境的隔离，实现的效果就是容器中的进程只能看到Namespace隔离之后的容器“环境”。

这时我们就不难发现，其实容器都是共用宿主机的OS的，容器并不像虚拟机一样，有一整套完整的OS，这样容器的进程就可以和宿主机上的其他进程一样，统一由宿主机的操作系统来进行管理，所以相对于虚拟机来说，容器中的进程不会受到因为虚拟化而带来性能损失的影响，但是这也会有一个问题存在，Namespace只是做了一个限制，限制某些东西能看到，某些东西你不能看到，但是这样的隔离是不彻底的。不过，这并不影响docker技术的流行。

说完了Namespace的“环境”隔离，我们下面来说一下Cgroups技术的“资源”限制。

既然一台宿主机上可以起多个容器，那么对于容器中的一个运行中的进程来说，如果正在运行的过程中，他所需要的资源（如：CPU、Memory）让其他容器的进程抢夺完了，这显然是不合理，那么容器是如何做到资源隔离的呢？这就要说一下Linux的Cgroups技术了，它的主要作用就是限制一个进程组可以使用的资源的上限，如：CPU、Memory、磁盘等。
